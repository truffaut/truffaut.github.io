---
layout: post
title:  "5 Tips for Beginning Programmers"
---

# 5 Tips for Beginning Programmers

Well, I've realized that I may have been too ambitious in my idea to start an entire series on practical Unix for web developers. In the interest of actually writing more posts, I've decided to go with standalone, easier-to-write posts that fit with my schedule a little bit more. I'll try to come back to Practical Unix when I can!

1. Don't get hung up on environment and terminal issues, it sucks even for experienced programmers. Use something like terminal.com to get to work without having to worry about breaking **everything**. If you are super lazy like me, you can even start executing code directly in the console tab of the Developer Tools built into Chrome (read: https://developer.chrome.com/devtools/docs/console).
2. Focus on fundamental concepts. Think about how to use the basic programming constructs you've learned to actually solve problems. You don't need complicated built-in methods in the standard library to accomplish tasks, even if you only have variables, arrays, conditionals, loops and functions, you can solve all kinds of complicated problems.
3. Plan out what your functions are going to do before you start writing them. Even before you start using something like TDD, you should write out the various steps your function is going to take in plain-english comments.
4. Don't get hung up on programming language choices. Don't worry about whether or not the language you are working with will have "jobs", instead focus on languages that you enjoy using primarily and languages where you can get the most help and assistance as a beginner secondly. If you focus on thinking and executing like a programmer, you'll have no trouble switching from language to language in no time.
5. Don't get hung up on choices in general. There is a concept YAGNI (You Ain't Gonna Need it) which states that you should only build out functionality when it's actually necessary to build it. That's easy to say, and often hard to follow. There's a lot of temptation when you're building something to think "well, since I *will probably* want to do X, Y and Z, it *seems* like it might be easier to build my methods to work with X, Y and Z ahead of time so that when it comes time to create X, Y and Z, it will be easier". Next thing you know, your design considerations have changed, you are no longer going to add X, Y and Z, but your application is still structured for that change, and your preparation time upfront was wasted, and worse, your design was compromised for functionality that was never implemented. Save yourself some time, resist temptation.
